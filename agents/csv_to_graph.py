#create a class that encapsulates data-viz logic
#make swapping models easy (models should be configurable anyway)
#expose the service thru a FLASK https://medium.com/@vkgcloud7/how-i-built-my-first-ai-agent-using-python-f19120ae597d
#then, create a website that can communicate with material agents (maybe bootstrap from existing chat bot )
#figure out how to get the csv


from langgraph.graph import MessagesState, END
from langchain_core.language_models.chat_models import BaseChatModel
from pydantic import BaseModel, Field
from typing import Any, Dict, List, Literal
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage
from enum import Enum
import altair as alt
import uuid

from utils.database_accessor import execute_query, extract_unique_nouns, get_table_schema

# region Structured Output Classes

class RelevantTable(BaseModel):
    """Represents a table relevant to the user's question."""
    table_name: str = Field(description="Name of the table relevant to the user's question")
    columns: List[str] = Field(description="List of column names in this table")
    noun_columns: List[str] = Field(description="Subset of columns that represent key noun entities")

class QueryParsing(BaseModel):
    """Structured output for matching user question with table"""
    is_relevant : bool = Field(description="Indicates if the user's question is clear and answerable, and relevant to the data being stored")
    relevant_tables : List[RelevantTable] = Field(
        default_factory=list,
        description="List of tables relevant to the user's question, including key noun columns"
    )

class VisualizationType(str, Enum):
    bar = "bar"
    horizontal_bar = "horizontal_bar"
    line = "line"
    pie = "pie"
    scatter = "scatter"
    none = "none"

class VisualizationRecommendation(BaseModel):
    """Structured output for recommending data visualization based on user question"""
    recommended_visualization: VisualizationType = Field(description="Recommended chart type")
    reason: str = Field(..., description="Explanation for the recommendation")

class State(MessagesState):
    """Extended state with conversation tracking"""
    question : str = Field(description="Question regarding data")
    parsed_question: QueryParsing = Field(description="Question asked by user regarding the data stored but parsed to extract its most important features")
    unique_nouns : List[str] = Field(
        default_factory=list,
        description="List of unique nouns relevant to the user's question"
    )
    valid_sql : str = Field("SQL query based of user")
    sql_result_rows : List[Dict[str, Any]] = Field(
        default_factory=list,
        description="List of rows generated from valid_sql"
    )
    recommended_visualization : VisualizationType = Field(description="Recommended chart type")
    visualization_reason: str = Field(description="Explanation for the recommendation")
    generated_chart : str = Field(description="Directory of chart generated by the AI")

class SqlAgentCorrection(BaseModel):
    """Structured output for correcting SQL generated by the agent"""
    valid: bool = Field(description="Checks whether given SQL was valid or not. If invalid (valid==false), then there will be corrections")
    issues: str = Field(description="Issues with the SQL given. Is empty if the SQL given was already correct")
    corrected_query: str = Field(description="Correction of the given SQL. Is empty if the SQL given was already correct")

# endregion

class CsvToGraphAgent:
    """Represents agents who can convert csv to graphs based on queries."""

    PLACEHOLDER_TABLE_NAME = "movies_with_year"

    def __init__(self, model : BaseChatModel, table_name: str):
        self.model = model
        self.table_name = table_name

    def parse_user_question(self, state: State) -> State:
        last_message = state["messages"][-1]

        prompt = f"""You are a data analyst that can help summarize SQL tables and parse user questions about a database. 
Given the question and database schema, identify the relevant tables and columns. 
If the question is not relevant to the database or if there is not enough information to answer the question, set is_relevant to false.

The "noun_columns" field should contain only the columns that are relevant to the question and contain nouns or names and NOT NUMBERS, for example, the column "Artist name" contains nouns relevant to the question "What are the top selling artists?", but the column "Artist ID" or "Artist Rating" is not relevant because it does not contain a noun. Do not include columns that contain numbers.
Remove all noun_columns that are all numbers.

No same table can appear twice. 

            **User Query:**
            `"{last_message.content}"`
            
            **Schemas:**
            {get_table_schema(self.table_name)}
        """
        llm_with_structure = self.model.with_config(temperature=0.2).with_structured_output(QueryParsing)
        response = llm_with_structure.invoke([SystemMessage(content=prompt)])

        if (response.is_relevant):
            state['parsed_question'] = response
            return state
        else:
            clarification = "I need more information to understand your question."
            return {"messages": [AIMessage(content=clarification)]}
        
    def get_unique_nouns(self, state: State) -> State:
        """Find unique nouns in relevant tables and columns."""
        parsed_question = state['parsed_question']
        
        if not parsed_question.is_relevant:
            return {"unique_nouns": []}

        unique_nouns = []
        for table_info in parsed_question.relevant_tables:
            table_name = table_info.table_name
            noun_columns = table_info.noun_columns
            
            if noun_columns:
                unique_nouns.append(extract_unique_nouns(table_name, noun_columns))

        state["unique_nouns"] = list(unique_nouns)

        return {"unique_nouns": state["unique_nouns"]}

    def get_sql_query(self, state: State) -> State:
        parsed_question = state['parsed_question']
        last_message = state["messages"][-1]

        if not parsed_question.is_relevant:
            return ""
        else:
            unique_nouns = self.get_unique_nouns(state)
           
        prompt = f"""You are an AI assistant that generates SQL queries based on user questions, database schema, and unique nouns found in the relevant tables. Generate a valid SQL query to answer the user's question.
          
If there is not enough information to write a SQL query, respond with "NOT_ENOUGH_INFO". When using nouns, use only the unique nouns.
DO NOT make any DML statements (INSERT, UPDATE, DELETE, DROP etc.) to the database.

Here are some examples:

1. What is the top selling product?
Answer: SELECT product_name, SUM(quantity) as total_quantity FROM sales WHERE product_name IS NOT NULL AND quantity IS NOT NULL AND product_name != "" AND quantity != "" AND product_name != "N/A" AND quantity != "N/A" GROUP BY product_name ORDER BY total_quantity DESC LIMIT 1

2. What is the total revenue for each product?
Answer: SELECT product_name, SUM(quantity * price) as total_revenue FROM sales WHERE product_name IS NOT NULL AND quantity IS NOT NULL AND price IS NOT NULL AND product_name != "" AND quantity != "" AND price != "" AND product_name != "N/A" AND quantity != "N/A" AND price != "N/A" GROUP BY product_name ORDER BY total_revenue DESC

3. What is the market share of each product?
Answer: SELECT product_name, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM sales) as market_share FROM sales WHERE product_name IS NOT NULL AND quantity IS NOT NULL AND product_name != "" AND quantity != "" AND product_name != "N/A" AND quantity != "N/A" GROUP BY product_name ORDER BY market_share DESC

4. Plot the distribution of income over time
Answer: SELECT income, COUNT(*) as count FROM users WHERE income IS NOT NULL AND income != "" AND income != "N/A" GROUP BY income
             
For questions like "plot a distribution of the fares for men and women", count the frequency of each fare and plot it. The x axis should be the fare and the y axis should be the count of people who paid that fare.
SKIP ALL ROWS WHERE ANY COLUMN IS NULL or "N/A" or "".
             """
        human_question = f"""
            **Database Schema:**
            `"{" ".join(get_table_schema(table.table_name) for table in parsed_question.relevant_tables)}"`
            
            **User question:**
            {last_message.content}

            **Relevant tables and columns:**
            {parsed_question}

            **Unique nouns in relevant tables:**
            {unique_nouns["unique_nouns"]}
            """
          
        response = self.model.with_config(temperature=0.2).invoke([SystemMessage(content=prompt), HumanMessage(content=human_question)])

        state["valid_sql"] = response.content

        return state

    def validate_and_fix_sql(self, state: State)->State:
        parsed_question = state['parsed_question']

        prompt = f"""
You are an AI assistant that validates and fixes SQL queries. Your task is to:
1. Check if the SQL query is valid.
2. Ensure all table and column names are correctly spelled and exist in the schema.
3. If there are any issues, fix them and provide the corrected SQL query.
4. If no issues are found, return the original query.
5. When correcting the query, always return a single-line SQL that can be executed immediately
6. Add double quotes for column names that have spaces. DO NOT ESCAPE, JUST WRITE IT AS IT IS

Respond in JSON format with the following structure. Only respond with the JSON:
{{
    "valid": boolean,
    "issues": string or null,
    "corrected_query": string
}}
            """
        human_question = f"""
**Database Schema:**
`"{" ".join(get_table_schema(table.table_name) for table in parsed_question.relevant_tables)}"`

===Generated SQL query:
{state['valid_sql']}

Respond in JSON format with the following structure. Only respond with the JSON:
{{
    "valid": boolean,
    "issues": string or null,
    "corrected_query": string
}}

For example:
1. {{
    "valid": true,
    "issues": null,
    "corrected_query": "None"
}}
            
2. {{
    "valid": false,
    "issues": "Column USERS does not exist",
    "corrected_query": "SELECT * FROM users WHERE age > 25"
}}
                """
        llm_with_structure = self.model.with_config(temperature=0.2).with_structured_output(SqlAgentCorrection)
        response = llm_with_structure.invoke([SystemMessage(content=prompt), HumanMessage(content=human_question)])

        state["valid_sql"] = state['valid_sql'] if response.valid else response.corrected_query

        return state
    
    def execute_sql(self, state: State)->State:
        state["sql_result_rows"] = execute_query(state["valid_sql"])["rows"]

        return state

    def choose_visualization(self, state: State)->VisualizationRecommendation:
        last_message = state["messages"][-1]

        prompt = f"""
    ou are an AI assistant that recommends appropriate data visualizations. Based on the user's question, SQL query, and query results, suggest the most suitable type of graph or chart to visualize the data. If no visualization is appropriate, indicate that.

    Available chart types and their use cases:

    - Bar Graphs: Best for comparing categorical data or showing changes over time when categories are discrete and the number of categories is more than 2. Use for questions like "What are the sales figures for each product?" or "How does the population of cities compare? or "What percentage of each city is male?"
    - Horizontal Bar Graphs: Best for comparing categorical data or showing changes over time when the number of categories is small or the disparity between categories is large. Use for questions like "Show the revenue of A and B?" or "How does the population of 2 cities compare?" or "How many men and women got promoted?" or "What percentage of men and what percentage of women got promoted?" when the disparity between categories is large.
    - Scatter Plots: Useful for identifying relationships or correlations between two numerical variables or plotting distributions of data. Best used when both x axis and y axis are continuous. Use for questions like "Plot a distribution of the fares (where the x axis is the fare and the y axis is the count of people who paid that fare)" or "Is there a relationship between advertising spend and sales?" or "How do height and weight correlate in the dataset? Do not use it for questions that do not have a continuous x axis."
    - Pie Charts: Ideal for showing proportions or percentages within a whole. Use for questions like "What is the market share distribution among different companies?" or "What percentage of the total revenue comes from each product?"
    - Line Graphs: Best for showing trends and distributionsover time. Best used when both x axis and y axis are continuous. Used for questions like "How have website visits changed over the year?" or "What is the trend in temperature over the past decade?". Do not use it for questions that do not have a continuous x axis or a time based x axis.

    Consider these types of questions when recommending a visualization:

    1. Aggregations and Summarizations (e.g., "What is the average revenue by month?" - Line Graph)

    2. Comparisons (e.g., "Compare the sales figures of Product A and Product B over the last year." - Line or Column Graph)

    3. Plotting Distributions (e.g., "Plot a distribution of the age of users" - Scatter Plot)

    4. Trends Over Time (e.g., "What is the trend in the number of active users over the past year?" - Line Graph)

    5. Proportions (e.g., "What is the market share of the products?" - Pie Chart)

    6. Correlations (e.g., "Is there a correlation between marketing spend and revenue?" - Scatter Plot)

    Provide your response in the following format:

    Recommended Visualization: [Chart type or "None"]. ONLY use the following names: {", ".join(v.value for v in VisualizationType)}

    Reason: [Brief explanation for your recommendation]
            """

        llm_with_structure = self.model.with_config(temperature=0.2).with_structured_output(VisualizationRecommendation)
        response = llm_with_structure.invoke([SystemMessage(content=prompt), last_message])
        
        state["recommended_visualization"] = response.recommended_visualization
        state["visualization_reason"] = response.reason

        return response
    
    def answer_with_data(self, state : State):
        question = state["messages"][-1]
        results = state["sql_result_rows"]
        query = state["valid_sql"]

        system_prompt = """
    You are a helpful data analyst.
    Given a user question and SQL results, write a clear, concise answer.
    Use bullet points if helpful. 
    If it's numeric data, summarize key values.
    If it's a table, describe important patterns.
    """

        messages = [
            SystemMessage(content=system_prompt),
            HumanMessage(
                content=f"User question: {question}\n SQL results:\n{results}\nSQL query: {query}"
            )
        ]

        response = self.model.with_config(temperature=0.2).invoke(messages)

        return {"messages": [response]} 
    
    def vega_lite_visualizer(self, state: State) -> str:
        prompt = f"""
    You are a data visualization expert.

    Your job:
    1. Determine appropriate chart encoding based on summary stats.
    2. Generate Vega-Lite v5 JSON.
    3. Determine the appropriate formatting, such as labeling and color as well to maximize understanding
    4. Do NOT explain — output ONLY valid JSON.

    Inputs:
    - user question
    - SQL
    - SQL result rows
    - recommended visualization type

    Rules:
    - Use "data" from SQL result rows ("values")
    - Only use fields present in the data
    - Vega-Lite v5 only
    - No comments, no backticks

    Output: <JSON>
    """
        
        human_inputs = f"""
    - user question
    {state['messages'][-1]}
    - table schemas
    {state['parsed_question'].relevant_tables}
    - resulting SQL
    {state['valid_sql']}
    - SQL result rows ("values")
    {state['sql_result_rows']}
    - recommended visualization type
    {state['recommended_visualization']}
        """

        response = self.model.with_config(temperature=0.2).invoke([SystemMessage(content=prompt), HumanMessage(content=human_inputs)])

        prompt = f""" 
    You are a Vega-Lite specification corrector.

    Your job:
    - Take any Vega-Lite specification (JSON or near-JSON).
    - Detect all mistakes.
    - Fix the specification so it is VALID Vega-Lite v5.
    - Output ONLY valid JSON — no explanation, no comments, no backticks.

    Rules you MUST enforce:
    - Use "$schema": "https://vega.github.io/schema/vega-lite/v5.json".
    - If a mark is defined, it must be under "mark", not under "type".
    - "color" encoding must have either:
        - a "field" + optional "scale", OR
        - a fixed "value".
    Never include "values" inside "color".
    - All channels must follow Vega-Lite standards (x, y, color, size, tooltip, etc.).
    - If "layer" is used, each layer must contain its own "mark" and "encoding". 
    - "config" is only at top-level, cannot be layer-level
    - Make sure all fields exist in the provided data values.
    - No trailing commas. No extra text. Output must parse as JSON.
    - If something is invalid, fix it — do not delete data unless required.

    Below is a sample single view specification
    {{
    //Properties for top-level specification (e.g., standalone single view specifications)
    "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
    "background": ...,
    "padding": ...,
    "autosize": ...,
    "config": ...,
    "usermeta": ...,

    // Properties for any specifications
    "title": ...,
    "name": ...,
    "description": ...,
    "data": ...,
    "transform": ...,

    // Properties for any single view specifications
    "width": ...,
    "height": ...,
    "mark": ...,
    "encoding": {{
        "x": {{
        "field": ...,
        "type": ...,
        ...
        }},
        "y": ...,
        "color": ...,
        ...
    }}
    }}

    Process:
    1. Parse the input, even if malformed.
    2. Infer user intent.
    3. Repair the structure.
    4. Return the corrected Vega-Lite JSON.
        """

        human_inputs = f""" 
        Now correct this Vega-Lite specification:
        {response.content}
        """
        response = self.model.with_config(temperature=0.2).invoke([SystemMessage(content=prompt), HumanMessage(content=human_inputs)])
        
        return response.content

    def llm_json_fix(self, text: str)->str:
        prompt = f"""
    Your job is to FIX JSON AND CORRECT FORMAT FOR VEGA-LITE.

    Below is a sample single view specification
    {{
    //Properties for top-level specification (e.g., standalone single view specifications)
    "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
    "background": ...,
    "padding": ...,
    "autosize": ...,
    "config": ...,
    "usermeta": ...,

    // Properties for any specifications
    "title": ...,
    "name": ...,
    "description": ...,
    "data": ...,
    "transform": ...,

    // Properties for any single view specifications
    "width": ...,
    "height": ...,
    "mark": ...,
    "encoding": {{
        "x": {{
        "field": ...,
        "type": ...,
        ...
        }},
        "y": ...,
        "color": ...,
        ...
    }}
    }}

    Given the following text, extract ONLY valid JSON.
    If the JSON is invalid, rewrite it into valid, syntactically correct JSON.
    Do not add new fields. Do not remove fields unless required.
    Output ONLY JSON. No explanation.

    Remove any "config" fields if they are not at top level of JSON

    Text:
    {text}
    """
        response = self.model.with_config(temperature=0.2).invoke([SystemMessage(content=prompt)])
        content = response.content

        return content

    def visualize(self, state : State):
        vega_spec= self.vega_lite_visualizer(state)
        vega_spec = self.llm_json_fix(vega_spec)
        
        chart = alt.Chart.from_json(str(vega_spec))
        filename = str(uuid.uuid4())
        chart.save(filename, format="png")

        state["generated_chart"] = filename

        return state


    def answer_with_visual(self, state : State):
        question = state["messages"][-1]
        results = state["sql_result_rows"]
        query = state["valid_sql"]
        visualization = state["recommended_visualization"]

        system_prompt = """
    You are a helpful data analyst. 
    Given SQL results and an image visualization, generate a clear, concise answer.
    Explain insights from the chart and reference the data. 
    Keep it under 5 sentences unless necessary.

    You expect every message to be accompanied with a graph that your message describes
    """
        messages = [
            SystemMessage(content=system_prompt),
            HumanMessage(
                content=f"""
    User question: {question} 
    SQL query: {query} 
    SQL results:{results} 
    Recommended visualization style: {visualization}
    """
            )
        ]

        response = self.model.with_config(temperature=0.2).invoke(messages)
        
        return {"messages": [response]} 

    def route_after_question_parse(self, state: State) -> str :
        """Route to agent if question is clear, otherwise wait for human input"""
        return "get_unique_nouns" if state["parsed_question"].is_relevant else END

    def route_after_choose_visualization(self, state: State) -> Literal["visualize", "answer_with_data"]:
        return "visualize" if state["recommended_visualization"] != "none" else "answer_with_data"
